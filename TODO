
DOING
[ ] MAL msg. include list of mal peers
[ ] connect to all malnodes

HIGH
[ ] New nodes registration (if not connected to monitor when receiving POC)
[ ] Counter, before disconnect for VERIFIED. Needed to allow new nodes to be verified
[ ] Make MAX_VERIFICATION_TIMEOUT and AVG_UPDATE as bitcoind options

LOW
[X] List of monitors
[ ] Make g_verified a std::map
[ ] change fVerified[mon] to fVerified[pocId] ?

EXPERIMENTS
[ ] until registration not implemented, monitors should be manually connected to all nodes
[ ] until MAL not fully implemented, malicious nodes should be manually connected to each other

PAPER
[X] menzionare che nodi riconoscono verified peers da name se outbound, e da poc se inbound
[X] malicious monitors do not verify any connection - this is the worst case, in which they try to disconnect the whole network
[X] malicious node drops all POCs. there's no point in dropping only for some monitors, as this would not result in the connection to be hidden. Their attack can only succeeds if they hide from the majority of monitors, which is precisely the case in which the node reacts by disconnecting from it.
[ ] malicious node can fw to other malicious node both POC coming form the monitor and another inbound peer.
    - in the 'monitor' case, if the whole chain is malicious, they can fake the connection. if one of them is honest, it will drop the message
    - in the 'peer' case, the peer can warn the monitor about a fake verified peer
    .we implement a malicious node which fw pocs to all malicious nodes. they identify each other by using a MAL msg
    .our malicious node do not fw to honest nodes, as this would always result in a failure
        .if they receive POC from honest node, send to other malicious
        .if coming from malicious node, which is the target, send it to other malicious nodes
    .malicious nodes ignore the verified system and do not disconnect from anyone
    .malicious nodes advertise other malicious nodes to the others via MAL msg, so that they all connect to each other
    .in any case, if poc is received by the target, it's forwarded to all malicious peers
    .if coming from a different peer (not the target, nor the peer), let's send it to the monitor

DONE
[X] Regular nodes: set pocid into CVerified when received from peer
[X] remove disconnected from g_verified
[X] exclude monitor from g_verified
[X] Forward POC to outbound peers


**********************************************************************
OLD
HIGH PRIORITY

[ ] Set MAX_VERIFICATION_TIMEOUT to max seen ping
[ ] unverified (timeout)
[ ] TODO12
[ ] TODO22
[ ] Add CPeer*p1,p2 in CPoC
[ ] Update nodes after sending Alert
[ ] Only save outbound peers ? - return only outbound in topology?
[ ] Put CNetNode in CPeer
[ ] Delete CNetNode if node disconnects
[ ] Move cross-check to beginning of recv(PEERS):
    - findPeer(peer.IP) #This only works when IPs are different
    - 2 public nodes can run on the same IP. we cannot assume we know the node by knowing the base IP
[ ] Delete disconnected nodes? - maybe we just losed connection. check if it's anyone's peer
[X] When poc expires, stop checking it!!
    - [ ] Delete it?
[ ] ? Eliminate inbound peers from peerlist ?
[ ] If we receive an inbound peer, check if we tried poc and failed. if so report to node

LOW PRIORITY
[ ] Replace nNow with current_time
[ ] BCLog::POC #Keep basic log as NET, and 2nd-level log as POC
[ ] Create a POC list to quickly find a POC when receiving it back
[ ] Optimization: keep sending poc on verified connections; peers only send new peers
[ ] TODO01

---------------------------
[X] Put CNetNode * in CNode
[X] Put CPoC in CNetNode
[X] When starting new round, don't set peer as unverified if they already are
 |
 -- [X] Check when !fVerified is used
[X] fVerified = false when POC fails
